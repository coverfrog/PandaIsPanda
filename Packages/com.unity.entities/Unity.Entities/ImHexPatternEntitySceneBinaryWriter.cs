#if UNITY_DOTS_IMHEX
using System;
using System.CodeDom.Compiler;
using System.Collections.Generic;
using System.IO;
using System.Reflection;
using Unity.Collections;
using Unity.Collections.LowLevel.Unsafe;

namespace Unity.Entities
{
    public struct ImHexPatternEntitySceneBinaryWriter : IDisposable
    {
        public static World currentWorld { private get; set; }

        public bool shouldWriteToDisk { private get; set; }

        public string fileName { get; set; }

        IndentedTextWriter m_IndentedTextWriter;
        HashSet<Type> m_AlreadyWrittenTypes;
        HashSet<string> m_AlreadyWrittenTypeNames;
        HashSet<string> m_AlreadyWrittenOuterVariableNames;

        public static unsafe ImHexPatternEntitySceneBinaryWriter Create(string fileName, string headerAppend = "", EntityManager entityManager = default)
        {
            if (entityManager.GetUncheckedEntityDataAccess() == null)
                entityManager = currentWorld?.EntityManager ?? World.DefaultGameObjectInjectionWorld?.EntityManager ?? default;

            if (entityManager.GetUncheckedEntityDataAccess() != null)
                headerAppend += CreateStableTypeNameFunction(entityManager);

            var writer = new ImHexPatternEntitySceneBinaryWriter
            {
                shouldWriteToDisk = true,
                m_IndentedTextWriter = new IndentedTextWriter(new StringWriter()),
                m_AlreadyWrittenTypes = new HashSet<Type>(),
                m_AlreadyWrittenTypeNames = new HashSet<string>(),
                m_AlreadyWrittenOuterVariableNames = new HashSet<string>(),
                fileName = fileName
            };
            writer.WriteHeader(headerAppend, fileName);
            return writer;
        }

        static string CreateStableTypeNameFunction(EntityManager entityManager)
        {
            using var writer = new IndentedTextWriter(new StringWriter());
            using var allTypes = new NativeHashSet<ComponentType>(100, Allocator.Temp);
            using var archetypes = new NativeList<EntityArchetype>(Allocator.Temp);

            entityManager.GetAllArchetypes(archetypes);
            foreach (var archetype in archetypes)
            {
                unsafe
                {
                    if (archetype.Archetype->EntityCount == 0)
                        continue;
                }

                using var componentTypes = archetype.GetComponentTypes();
                foreach (var componentType in componentTypes)
                    allTypes.Add(componentType);
            }

            // StableTypeHash value mapper
            writer.WriteLine("/// StableTypeHash values are used to identify types in the binary format. This function maps the StableTypeHash to a human-readable name.");
            writer.WriteLine("fn get_stabletype_name(u64 stableTypeHash) {");
            writer.Indent++;
            writer.WriteLine("str name = \"\";");
            writer.WriteLine("match (stableTypeHash) {");
            writer.Indent++;

            foreach (var componentType in allTypes)
            {
                var typeInfo = TypeManager.GetTypeInfo(componentType.TypeIndex);
                writer.WriteLine($"\t({typeInfo.StableTypeHash}): name = \"{typeInfo.Type?.FullName ?? typeInfo.DebugTypeName.ToString()}\";");
            }

            writer.WriteLine("\t(_): name = \"Unknown Type\";");
            writer.Indent--;
            writer.WriteLine("}");
            writer.WriteLine();
            writer.WriteLine(@"return std::format(""{} (sth:{})"", name, stableTypeHash);");
            writer.Indent--;
            writer.WriteLine("};");

            return writer.InnerWriter.ToString();
        }

        void WriteHeader(string headerAppend, string name)
        {
            m_IndentedTextWriter.WriteLine($"// This file is auto-generated by ImHexPatternEntitySceneBinaryWriter for '{name}'");
            m_IndentedTextWriter.WriteLine("// Do not edit this file manually.");
            m_IndentedTextWriter.WriteLine();

            m_IndentedTextWriter.WriteLine(headerAppend);
        }

        public void WriteArrayOfTypeWithPosition<T>(string name, long position, int elementCount, string comment = "") => WriteArrayOfTypeWithPosition(typeof(T), name, position, elementCount, comment);
        public void WriteArrayOfTypeWithPosition(Type type, string name, long position, int elementCount, string comment = "")
        {
            if (!type.IsPrimitive)
                WriteImHexType(type);
            var newName = name;
            var index = 0;
            while (!m_AlreadyWrittenOuterVariableNames.Add(newName))
            {
                newName = $"{name}_{++index}";
            }

            m_IndentedTextWriter.WriteLine($"{GetImHexPatternNameForType(type)} {newName}[{elementCount}] @ {position}{GetCommentText(comment)};");
        }

        void WriteImHexType(Type type)
        {
            var typeQueue = CollectTypes(type);
            while (typeQueue.Count > 0)
                WriteType(typeQueue.Dequeue());
        }
        
        enum TypeBucket
        {
            None = 0,
            User = 1,
            Unity = 2,
            System = 3
        }
        
        Queue<Type> CollectTypes(Type currentType)
        {
            var processingStack = new List<Type> { currentType };
            var processedTypes = new HashSet<Type>();

            var systemQueue = new Queue<Type>();
            var unityQueue = new Queue<Type>();
            var userQueue = new Queue<Type>();
            
            while (processingStack.Count > 0)
            {
                var startingIndex = processingStack.Count - 1;
                currentType = processingStack[startingIndex];
                if (m_AlreadyWrittenTypes.Contains(currentType) || processedTypes.Contains(currentType))
                {
                    processingStack.RemoveAt(startingIndex);
                    continue;
                }
                
                var currentTypeBucket = GetTypeBucket(currentType);
                var hasAddedSameTypeBucketToStack = CollectGenericTypes(currentType, currentType, currentTypeBucket, processedTypes, processingStack);

                if (currentType.IsArray)
                {
                    var arrayType = currentType.GetElementType();
                    if (arrayType != null 
                        && !arrayType.IsPrimitive
                        && !m_AlreadyWrittenTypes.Contains(arrayType) 
                        && !processedTypes.Contains(arrayType))
                    {
                        processingStack.Add(arrayType);
                        
                        hasAddedSameTypeBucketToStack |= currentTypeBucket == GetTypeBucket(arrayType);
                        hasAddedSameTypeBucketToStack |= CollectGenericTypes(arrayType, currentType, currentTypeBucket, processedTypes, processingStack);
                    }
                }                
                
                var fields = GetUniqueRuntimeFieldTypes(currentType);
                foreach (var fieldType in fields)
                {
                    if (m_AlreadyWrittenTypes.Contains(fieldType) || processedTypes.Contains(fieldType))
                        continue;

                    // Add non-primitives that are also not fixed buffer types of primitives
                    if (!fieldType.IsPrimitive && fieldType != typeof(void*))
                    {
                        processingStack.Add(fieldType);
                        hasAddedSameTypeBucketToStack |= currentTypeBucket == GetTypeBucket(fieldType);
                        hasAddedSameTypeBucketToStack |= CollectGenericTypes(fieldType, currentType, currentTypeBucket, processedTypes, processingStack);
                    }
                }

                // Detect if there's a circular dependency. If so, write the type to the queue to break the circle.
                var alreadyHasTypeInStack = false;
                for (var i = 0; i < processingStack.Count; ++i)
                {
                    if (i == startingIndex)
                        continue;
                    if (processingStack[i] != currentType) 
                        continue;
                    
                    alreadyHasTypeInStack = true;
                    break;
                }
                
                if (!hasAddedSameTypeBucketToStack || alreadyHasTypeInStack)
                {
                    processingStack.Remove(currentType);
                    processedTypes.Add(currentType);
                    
                    // No need to add array types to stack, as we only need the array element type in ImHex.
                    if (currentType.IsArray)
                        continue;
                    
                    switch (currentTypeBucket)
                    {
                        case TypeBucket.Unity:
                            unityQueue.Enqueue(currentType);
                            break;
                        case TypeBucket.System:
                            systemQueue.Enqueue(currentType);
                            break;
                        case TypeBucket.None:
                        case TypeBucket.User:
                        default:
                            userQueue.Enqueue(currentType);
                            break;
                    }
                }
            }
            
            var typeQueue = new Queue<Type>(systemQueue.Count + unityQueue.Count + userQueue.Count);
            foreach (var type in systemQueue)
                typeQueue.Enqueue(type);
            foreach (var type in unityQueue)
                typeQueue.Enqueue(type);
            foreach (var type in userQueue)
                typeQueue.Enqueue(type);
            return typeQueue;
        }

        static TypeBucket GetTypeBucket(Type type)
        {
            switch (type.Namespace)
            {
                case not null when type.Namespace.StartsWith("Unity"): 
                    return TypeBucket.Unity;
                case not null when type.Namespace.StartsWith("System"): 
                    return TypeBucket.System;
                default:
                    return TypeBucket.User;
            }
        }
        
        static IEnumerable<Type> GetUniqueRuntimeFieldTypes(Type type)
        {
            var fields = type.GetRuntimeFields();
            var uniqueTypes = new HashSet<Type>();
            foreach (var field in fields)
            {
                if (!field.IsStatic)
                    uniqueTypes.Add(field.FieldType);
            }
            return uniqueTypes;
        }        

        bool CollectGenericTypes(Type type, Type currentType, TypeBucket currentTypeBucket, HashSet<Type> processedTypes, List<Type> stack)
        {
            if (!type.IsGenericType) 
                return false;

            var hasAddedSameTypeBucketToStack = false;
            foreach (var genType in type.GenericTypeArguments)
            {
                if (currentType == genType ||
                    m_AlreadyWrittenTypes.Contains(genType) 
                    || processedTypes.Contains(genType))
                    continue;
                if (genType.IsPrimitive || genType.IsPointer)
                    continue;
                        
                stack.Add(genType);
                hasAddedSameTypeBucketToStack |= currentTypeBucket == GetTypeBucket(genType);
            }

            return hasAddedSameTypeBucketToStack;
        }

        void WriteType(Type type)
        {
            switch (type)
            {
                case var _ when m_AlreadyWrittenTypes.Contains(type):
                case var _ when m_AlreadyWrittenTypeNames.Contains(type.Name):
                    break;
                case var _ when type.IsPrimitive:
                    Debug.LogError($"Should not be hit, primitive type {TypeHelper.GetImHexSupportedFullName(type)} found in queue.");
                    break;
                case var _ when type.IsArray:
                    Debug.LogError($"Should not be hit, array type {TypeHelper.GetImHexSupportedFullName(type)} found in queue.");
                    break;
                case var _ when TypeHelper.IsUnityComponent(type):
                    WriteUnityComponent(m_IndentedTextWriter, type, sizeof(int));
                    m_AlreadyWrittenTypes.Add(type);
                    break;
                case var _ when TypeHelper.IsUnityObjectRef(type):
                    WriteUnityComponent(m_IndentedTextWriter, type, sizeof(long));
                    m_AlreadyWrittenTypeNames.Add(type.Name);
                    break;
                case var _ when type.IsEnum:
                    WriteEnum(m_IndentedTextWriter, type);
                    m_AlreadyWrittenTypes.Add(type);
                    break;
                default:
                    string typeStr;
                    if (type.IsGenericType || TypeHelper.IsFakeGeneric(type))
                    {
                        typeStr = GetGenericTypeString(type, false);
                        m_AlreadyWrittenTypeNames.Add(type.Name);
                    }
                    else if (TypeHelper.IsChunkComponent(type))
                        typeStr = "ChunkComponent";
                    else
                        typeStr = TypeHelper.GetImHexSupportedFullName(type);

                    m_IndentedTextWriter.WriteLine($"struct {typeStr} {{");
                    m_IndentedTextWriter.Indent++;

                    var fieldSizeCounter = 0;
                    foreach (var fieldInfo in type.GetFields())
                    {
                        WriteField(m_IndentedTextWriter, fieldInfo);
                        fieldSizeCounter += fieldInfo.FieldType.IsValueType ? UnsafeUtility.SizeOf(fieldInfo.FieldType) : GetSizeOfUnityClass(fieldInfo.FieldType);
                    }

                    m_IndentedTextWriter.Indent--;
                    var sizeOfType = type.IsValueType
                        ? UnsafeUtility.SizeOf(type)
                        : fieldSizeCounter;

                    m_IndentedTextWriter.WriteLine($"}} [[fixed_size({sizeOfType})]]{GetCommentText(GetPremadeComment(type))};\n");
                    m_AlreadyWrittenTypes.Add(type);
                    break;
            }
        }

        static void WriteUnityComponent(IndentedTextWriter writer, Type type, int componentSize)
        {
            writer.WriteLine($"struct {TypeHelper.GetImHexSupportedFullName(type)} {{");
            writer.Indent++;
            writer.WriteLine($"{GetImHexPatternNameForPrimitiveType(typeof(int))} instanceId @ addressof(this)+0;");
            writer.Indent--;
            writer.WriteLine($"}} [[fixed_size({componentSize})]]{GetCommentText(GetPremadeComment(type))};\n");
        }

        static void WriteEnum(IndentedTextWriter writer, Type type)
        {
            writer.WriteLine($"enum {TypeHelper.GetImHexSupportedFullName(type)} : {GetImHexPatternNameForPrimitiveType(type.GetEnumUnderlyingType())} {{");
            writer.Indent++;
            var enumNames = type.GetEnumNames();
            for (var i = 0; i < enumNames.Length; ++i)
            {
                writer.WriteLine(i < enumNames.Length - 1 ? $"{enumNames[i]}," : $"{enumNames[i]}");
            }
            writer.Indent--;
            writer.WriteLine("};");
        }

        static void WriteField(IndentedTextWriter writer, FieldInfo fieldInfo)
        {
            if (fieldInfo.IsStatic)
                return;

            var fieldType = fieldInfo.FieldType;
            switch (fieldType)
            {
                case var _ when fieldType.IsPointer || fieldType == typeof(IntPtr):
                    writer.Write($"{GetImHexPatternNameForPointerType(fieldType)} *{TypeHelper.GetImHexSupportedName(fieldInfo.Name)} : {GetImHexPatternNameForPrimitiveType(typeof(int))}");
                    break;
                case var _ when fieldType.IsPrimitive:
                    writer.Write($"{GetImHexPatternNameForPrimitiveType(fieldType)} {TypeHelper.GetImHexSupportedName(fieldInfo.Name)}");
                    break;
                case var _ when TypeHelper.IsUnityObjectRef(fieldType):
                    writer.Write($"{TypeHelper.GetImHexSupportedFullName(fieldType)} {TypeHelper.GetImHexSupportedName(fieldInfo.Name)}");
                    break;
                case var _ when fieldType.IsGenericType || TypeHelper.IsFakeGeneric(fieldType):
                    writer.Write($"{GetGenericTypeString(fieldType, true)} {TypeHelper.GetImHexSupportedName(fieldInfo.Name)}");
                    break;
                case var _ when TypeHelper.IsChunkComponent(fieldType):
                    writer.Write($"ChunkComponent {TypeHelper.GetImHexSupportedName(fieldInfo.Name)}");
                    break;
                case var _ when fieldType.IsArray:
                    var elementType = fieldType.GetElementType();
                    var typeName = elementType != null && elementType.IsPrimitive ? GetImHexPatternNameForPrimitiveType(elementType) : TypeHelper.GetImHexSupportedFullName(elementType);
                    writer.Write($"{typeName} {TypeHelper.GetImHexSupportedName(fieldInfo.Name)}[]");
                    break;
                default:
                    writer.Write($"{TypeHelper.GetImHexSupportedFullName(fieldType)} {TypeHelper.GetImHexSupportedName(fieldInfo.Name)}");
                    break;
            }
            writer.WriteLine($" @ addressof(this)+{UnsafeUtility.GetFieldOffset(fieldInfo)}{GetCommentText(GetPremadeComment(fieldType, TypeHelper.GetImHexSupportedName(fieldInfo.Name)))};");
        }

        static string GetPremadeComment(Type type, string fieldName = "") => type switch
        {
            { Name: "UInt64" } when fieldName is "StableTypeHash" => "StableTypeHash is a unique identifier for the type, used for serialization and deserialization.",
            _ => string.Empty
        };

        static string GetCommentText(string comment) => string.IsNullOrEmpty(comment) ? string.Empty : $" [[comment(\"{comment}\")]]";
        public void WriteTypeWithPosition<T>(string name, long position, string comment = "") => WriteTypeWithPosition(typeof(T), name, position, comment);
        public void WriteTypeWithPosition(Type type, string name, long position, string comment = "")
        {
            if (!type.IsPrimitive)
                WriteImHexType(type);
            var newName = name;
            var index = 0;
            while (!m_AlreadyWrittenOuterVariableNames.Add(newName))
            {
                newName = $"{name}_{++index}";
            }

            m_IndentedTextWriter.WriteLine($"{GetImHexPatternNameForType(type)} {newName} @ {position}{GetCommentText(comment)};");
        }

        static string GetImHexPatternNameForType(Type type)
        {
            if (type.IsPrimitive)
                return GetImHexPatternNameForPrimitiveType(type);
            if (type.IsGenericType)
                return GetGenericTypeString(type, true);

            return TypeHelper.GetImHexSupportedFullName(type);
        }

        static string GetGenericTypeString(Type type, bool shouldAddRealType)
        {
            var sb = new System.Text.StringBuilder();

            var typeName = type.FullName;
            typeName = TypeHelper.GetImHexSupportedName(typeName.Split('[')[0]);

            // System.Collections.Generic.Dictionary`2+ValueCollection[[System.String, mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089],[System.Int32, mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089]]
            // Will be converted to: System_Collections_Generic_Dictionary_2_ValueCollection<T0 ,T1>
            if (type.IsGenericType)
            {
                sb.Append($"{typeName}<");
                var genericArguments = type.GetGenericArguments();
                for (var i = 0; i < genericArguments.Length; ++i)
                {
                    sb.Append(shouldAddRealType ? GetImHexPatternNameForType(genericArguments[i]) : $"T{i}");

                    if (i < genericArguments.Length - 1)
                        sb.Append(" ,");
                }
            }
            // E.g. Unity.Entities.BlobArray`1[[Unity.Entities.SceneSectionData, Unity.Entities, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null]]
            // Will be converted to: Unity_Entities_BlobArray_1<T0>
            else
            {
                var fullName = type.FullName;
                var allArgs = fullName.Split('[')[2].Split(',');
                var noOfArgs = int.Parse(fullName[fullName.IndexOf('`') + 1].ToString());

                sb.Append($"{typeName}<");
                for (var i = 0; i < noOfArgs; ++i)
                {
                    sb.Append(shouldAddRealType ? allArgs[i].Replace('.', '_') : $"T{i}");

                    if (i < noOfArgs - 1)
                        sb.Append(" ,");
                }
            }

            sb.Append(">");
            return sb.ToString();
        }

        static string GetImHexPatternNameForPrimitiveType(Type type) => type switch
        {
            { Name: "Byte" } => "u8",
            { Name: "SByte" } => "s8",
            { Name: "Int16" } => "s16",
            { Name: "UInt16" } => "u16",
            { Name: "Int32" } => "s32",
            { Name: "UInt32" } => "u32",
            { Name: "Int64" } => "s64",
            { Name: "UInt64" } => "u64",
            { Name: "Single" } => "float",
            { Name: "Double" } => "double",
            { Name: "Boolean" } => "bool",
            { Name: "Char" } => "char",
            _ => throw new NotSupportedException($"Type '{TypeHelper.GetImHexSupportedFullName(type)}' is not a supported primitive by ImHexPatternEntitySceneBinaryWriter.")
        };

        static string GetImHexPatternNameForPointerType(Type type) => type switch
        {
            { Name: "Void*" } => "u32",
            { Name: "IntPtr" } => "u32",
            _ => TypeHelper.GetImHexSupportedFullName(type)
        };

        static int GetSizeOfUnityClass(Type type)
        {
            switch (type)
            {
                case var _ when type.Name == "CompanionReference":
                case var _ when type.IsGenericType && type.GetGenericTypeDefinition() == typeof(UnityObjectRef<>):
                default:
                    return sizeof(int);
            }
        }

        public void Dispose()
        {
            if (m_IndentedTextWriter == null)
                return;
            if (!shouldWriteToDisk)
            {
                m_IndentedTextWriter.Dispose();
                return;
            }

            WriteFooter();
            if (!Directory.Exists("./Library/GeneratedImHex"))
                Directory.CreateDirectory("./Library/GeneratedImHex");

            var filePath = $"./Library/GeneratedImHex/{Path.GetFileName(fileName)}.hexpat";
            File.WriteAllText(filePath, m_IndentedTextWriter.InnerWriter.ToString());

            Debug.Log($"Created an .hexpat file from the recent bake, located at: {filePath} (Size: {new FileInfo(filePath).Length} bytes)");
            m_IndentedTextWriter.Dispose();
        }

        void WriteFooter()
        {
            m_IndentedTextWriter.WriteLine("// End of auto-generated file.");
            m_IndentedTextWriter.Flush();
        }
    }

    internal static class TypeHelper
    {
        public static string GetImHexSupportedFullName(Type type) => GetImHexSupportedName(type.FullName);
        public static string GetImHexSupportedName(string name) => 
            name.Replace('.', '_')
            .Replace('+', '_')
            .Replace('<', '_')
            .Replace('>', '_')
            .Replace('`', '_')
            .Replace("*", string.Empty)
            .Split(',')[0]
            .Split('[')[0];

        public static bool IsChunkComponent(Type type) => type.FullName != null && type.FullName.Contains("Unity.Entities.Chunk+<Buffer>");
        public static bool IsUnityComponent(Type type) => type.IsClass &&
                                                               (type.IsSubclassOf(typeof(UnityEngine.Component)) ||
                                                                type.IsSubclassOf(typeof(UnityEngine.MonoBehaviour)) ||
                                                                type == typeof(UnityEngine.Transform) ||
                                                                type == typeof(UnityEngine.GameObject));
        public static bool IsFakeGeneric(Type type) => type is {FullName: not null} && type.FullName.Contains("`");
        public static bool IsUnityObjectRef(Type type) => type.Name.Contains("UnityObjectRef");
    }
}

#endif